/* FieldGenerator
 * 
 * This script creates the playfield by instantiating an 2D array of gameobjects
 * Idea is to create them in a "randomized order", to variate shape, size, rotation etc.
 * 
 * parameters for field should be generated by textfile
 * 
 * @mrv 24
 * 
 * TO DO
 * 
 * Create Holes
 * Make sure PATH is available
 * Create Player Stuff ---->>> DONE
 * 
 */

using System;
using System.Collections;
using System.Collections.Generic;
using Unity.Mathematics;
using UnityEngine;

public class FieldGenerator : MonoBehaviour
{
    #region PUBLICS

    public PlayerManager _PlayerManager;

    [Space(10)]

    public GameObject[] _PlayFieldPlane = new GameObject[2];

    [Space(10)]

    public GameObject _PlateauObject;

    #endregion

    #region PRIVATES

    [Space(10)]

    [SerializeField]
    private int _fieldWidth = 5;
    [SerializeField]
    private int _fieldHeight = 10;
    [SerializeField]
    private int _plateauRotation = 0;
    [SerializeField]
    private float _plateauSize = 0.8f;
    [SerializeField]
    private int _holeChance = 10;

    [Space(10)]

    [SerializeField]
    private float _plateauSpacing = .3f;

    [SerializeField]
    private float _maxWidth = 1f;
    [SerializeField]
    private float _maxHeight = 1f;

    private GameObject[][] _PlateauA = new GameObject[0][];
    private GameObject[][] _PlateauB = new GameObject[0][];

    private bool[][] _holes = new bool[0][];
    private bool[][] _path = new bool[0][];

    [SerializeField]
    private bool _showHoles = true;
    [SerializeField]
    private bool _showPaths = true;

    private bool _mirrorPlateauA = true;

    private PlateauProperties[][] _PlateauPropertiesA = new PlateauProperties[0][]; 
    private PlateauProperties[][] _PlateauPropertiesB = new PlateauProperties[0][];

    private Vector3 _tempVec = Vector3.zero;

    [Space(10)]

    // DEBUG STUFF
    [SerializeField]
    private bool _DEBUG_GENERATE = false;
    [SerializeField]
    private bool _DEBUG_DESTROY = false;

    #endregion

    #region UNITY_METHODS

    private void Start()
    {
        //GenerateField();
    }

    private void Update()
    {
        if (_DEBUG_GENERATE)
        {
            GenerateField();
            _DEBUG_GENERATE = false;
        }

        if (_DEBUG_DESTROY)
        {
            RemoveAllPlateaus();
            _DEBUG_DESTROY = false;
        }
    }

    #endregion

    #region METHODS

    public void GenerateField()
    {
        // in case field was generated before
        RemoveAllPlateaus();

        // creating all arrays
        _PlateauA = new GameObject[_fieldWidth][];
        _PlateauB = new GameObject[_fieldWidth][];

        _PlateauPropertiesA = new PlateauProperties[_fieldWidth][];  
        _PlateauPropertiesB = new PlateauProperties[_fieldWidth][]; 

        _holes = new bool[_fieldWidth][];
        _path = new bool[_fieldWidth][];

        for (int i = 0; i < _fieldWidth; i++)
        {
            _PlateauA[i] = new GameObject[_fieldHeight];
            _PlateauB[i] = new GameObject[_fieldHeight];
            _holes[i] = new bool[_fieldHeight];
            _path[i] = new bool[_fieldHeight];
            _PlateauPropertiesA[i] = new PlateauProperties[_fieldHeight];
            _PlateauPropertiesB[i] = new PlateauProperties[_fieldHeight];
        }

        Debug.LogWarning("Plateau Holes are generated randomly", this);

        int randomInt = 0;              // defines which plateau object is used for generation
        float randomRotation = 0f;      // rotates all plateaus randomly
        float randomScaleOffset = 0f;   // varies the size of plateaus minimaly
        float plateauUnitSize = _plateauSize + (_plateauSpacing * .5f); // plateauUnitSize is the "Size-per-field", including diameter of plateau and spacing!

        // filling PlayFields
        for (int i = 0; i < _PlateauA.Length; i++)
        {
            for (int j = 0; j < _PlateauA[i].Length; j++)
            {
                // randomly assigning Plateau-Object
                randomInt = Mathf.RoundToInt(UnityEngine.Random.Range(0f, 2f));
                _PlateauA[i][j] = Instantiate(_PlateauObject);
                _PlateauB[i][j] = Instantiate(_PlateauObject);
                _PlateauPropertiesA[i][j] = _PlateauA[i][j].GetComponent<PlateauProperties>();
                _PlateauPropertiesB[i][j] = _PlateauB[i][j].GetComponent<PlateauProperties>();

                _PlateauPropertiesA[i][j].EnablePlateauModel(randomInt);
                _PlateauPropertiesB[i][j].EnablePlateauModel(randomInt);

                // assigning IDs to Plateaus
                _PlateauPropertiesA[i][j].ID(i, j);
                _PlateauPropertiesB[i][j].ID(i, j);

                // assigning PlayfieldType
                _PlateauPropertiesA[i][j].PlayerType(0);
                _PlateauPropertiesB[i][j].PlayerType(1);

                // assigning Names to Plateaus
                _PlateauA[i][j].name = "Plateau_" + i + "_" + j;
                _PlateauB[i][j].name = "Plateau_" + i + "_" + j;

                // assigning Plateaus to parent playfield
                _PlateauA[i][j].transform.SetParent(_PlayFieldPlane[0].transform);
                _PlateauB[i][j].transform.SetParent(_PlayFieldPlane[1].transform);

                // defining Dimensions
                _maxHeight = _fieldHeight * plateauUnitSize;
                _maxWidth = _fieldWidth * plateauUnitSize;

                // placing grid
                _tempVec = Vector3.zero;
                _tempVec.x = (i * plateauUnitSize) - (_maxWidth / 2f) + (plateauUnitSize / 2f);
                _tempVec.z = (j * plateauUnitSize) - (_maxHeight / 2f) + (plateauUnitSize / 2f);

                _PlateauA[i][j].transform.localPosition = _tempVec;// + _PlayFieldPlane[0].transform.position;
                _PlateauB[i][j].transform.localPosition = _tempVec;// + _PlayFieldPlane[1].transform.position;
                
                // randomly assigning Plateau-Orientation
                randomRotation = UnityEngine.Random.Range(0f, 360f);
                _tempVec = Vector3.zero;
                _tempVec.y = randomRotation;
                _PlateauA[i][j].transform.eulerAngles = _tempVec;
                _PlateauB[i][j].transform.eulerAngles = _tempVec;

                // set Plateau-Size
                randomScaleOffset = UnityEngine.Random.Range(0f, 0.2f);
                _tempVec = new Vector3(_plateauSize - randomScaleOffset, _plateauSize - randomScaleOffset, _plateauSize - randomScaleOffset);
                _PlateauA[i][j].transform.localScale = _tempVec;
                _PlateauB[i][j].transform.localScale = _tempVec;

                // assigning holes (NEEDS REFACTORING!!!)
                randomInt = Mathf.RoundToInt(UnityEngine.Random.Range(0f, 100f));
                //Debug.Log("randomInt is " + randomInt, this);

                if (randomInt <= _holeChance)
                {
                    //Debug.Log("Setting holes to TRUE", this);
                    _holes[i][j] = true;
                }
                else
                {
                    _holes[i][j] = false;
                }

                _PlateauPropertiesA[i][j].IsHole(_holes[i][j]);
                _PlateauPropertiesB[i][j].IsHole(_holes[i][j]);

                _PlateauPropertiesA[i][j].ShowHoleVisibility(_showHoles);
                _PlateauPropertiesB[i][j].ShowHoleVisibility(_showHoles);

                _PlateauA[i][j].transform.position -= (_PlateauA[i][j].transform.up * i * j * 0.1f) + (_PlateauA[i][j].transform.up * 0.3f);
                _PlateauB[i][j].transform.position -= (_PlateauA[i][j].transform.up * i * j * 0.1f) + (_PlateauA[i][j].transform.up * 0.3f);

                _PlateauPropertiesA[i][j].Surface();
                _PlateauPropertiesB[i][j].Surface();

                
            }
        }

        // Generating path
        Debug.Log("Generating ensured Path", this);

        float dice = UnityEngine.Random.Range(0f, 100f);
        int row = 0;
        int col = Mathf.RoundToInt(UnityEngine.Random.Range(0, _PlateauPropertiesA.Length));

        while (row < _fieldHeight)
        {
            _path[col][row] = true;
            _holes[col][row] = false;

            dice = UnityEngine.Random.Range(0f, 100f);
            if (dice < 50f)
            {
                dice = UnityEngine.Random.Range(0f, 100f);
                if (dice < 50)
                {
                    col--;               
                }
                else
                {
                    col++;
                }

                if (col < 0)
                {
                    col += 2;
                }
                else if (col >= _fieldWidth)
                {
                    col -= 2;
                }

                _path[col][row] = true;
                _holes[col][row] = false;
            }
            
            row++;
        }

        for (int i = 0; i < _PlateauPropertiesA.Length; i++)
        {
            for (int j = 0; j < _PlateauPropertiesA[i].Length; j++)
            {
                _PlateauPropertiesA[i][j].IsPath(_path[i][j]);
                _PlateauPropertiesB[i][j].IsPath(_path[i][j]);

                _PlateauPropertiesA[i][j].IsHole(_holes[i][j]);
                _PlateauPropertiesB[i][j].IsHole(_holes[i][j]);
            }
        }
    }


    public void RemoveAllPlateaus()
    {
        try
        {
            for (int i = 0; i < _PlateauA.Length; i++)
            {
                for (int j = 0; j < _PlateauA[i].Length; j++)
                {
                    if (_PlateauA[i][j] != null) GameObject.Destroy(_PlateauA[i][j]);
                    if (_PlateauB[i][j] != null) GameObject.Destroy(_PlateauB[i][j]);

                    //Debug.Log("Destroying PLateau " + i + " " + j, this);
                }
            }
        }
        catch (Exception e)
        {
            Debug.LogError(e.Message);
        }
    }

    private void GenerateHoles()
    {

    }

    public void ShowHoles(bool show)
    {
        _showHoles = show;

        for (int i = 0; i < _PlateauPropertiesA.Length; i++)
        {
            for (int j = 0; j < _PlateauPropertiesA[i].Length; j++)
            {
                _PlateauPropertiesA[i][j].ShowHoleVisibility(_showHoles);
                _PlateauPropertiesB[i][j].ShowHoleVisibility(_showHoles);
            }
        }
    }

    public void SubmergeAllPlateaus()
    {
        for (int i = 0; i < _PlateauA.Length; i++)
        {
            for (int j = 0; j < _PlateauA[i].Length; j++)
            {
                if (_PlateauA[i][j] != null && _PlateauA[i][j].activeInHierarchy) _PlateauPropertiesA[i][j].Submerge();
                if (_PlateauB[i][j] != null && _PlateauA[i][j].activeInHierarchy) _PlateauPropertiesB[i][j].Submerge();
            }
        }
    }

    public void SubmergePlateausA()
    {
        for (int i = 0; i < _PlateauA.Length; i++)
        {
            for (int j = 0; j < _PlateauA[i].Length; j++)
            {
                if (_PlateauA[i][j] != null) _PlateauPropertiesA[i][j].Submerge();
            }
        }
    }

    public void MirrorPlayerStep(int type, int i, int j)
    {
        if (type == 0 && _mirrorPlateauA)
        {
            if (_PlateauB[i][j] != null && _PlateauA[i][j].activeInHierarchy) _PlateauPropertiesB[i][j].PlayerSteppedOnPlateau();
        }
        else if (type == 1)
        {
            if (_PlateauA[i][j] != null && _PlateauA[i][j].activeInHierarchy) _PlateauPropertiesA[i][j].PlayerSteppedOnPlateau();

            if (j == _fieldHeight - 1) _PlayerManager.GameWon();
        }

        if (_PlateauA[i][j] != null && _PlateauA[i][j].activeInHierarchy) _PlateauPropertiesA[i][j].TriggerHole();
        if (_PlateauB[i][j] != null && _PlateauA[i][j].activeInHierarchy) _PlateauPropertiesB[i][j].TriggerHole();

        if (_holes[i][j]) _PlayerManager.PlayerSteppedOnHole(type);
    }

    public void MirrorPlateauA(bool mirror)
    {
        _mirrorPlateauA = mirror;
    }

    public void FieldWidth(int width) { _fieldWidth = width; }
    public void FieldWidth(float width) { _fieldWidth = (int)width; }
    public int FieldWidth() { return _fieldWidth; }

    public void FieldHeight(int width) { _fieldHeight = width; }
    public void FieldHeight(float width) { _fieldHeight = (int)width; }
    public int FieldHeight() { return _fieldHeight; }

    public void HoleChance(int chance) { _holeChance = chance; }
    public void HoleChance(float chance) { _holeChance = (int)chance; }
    public int HoleChance() { return _holeChance; }

    public void PlateauRotation(int rotation) { _plateauRotation = rotation; }
    public void PlateauRotation(float rotation) { _plateauRotation = (int)rotation; }
    public int PlateauRotation() { return _plateauRotation; }

    public void PlateauSize(float size) { _plateauSize = size; }
    public float PlateauSize() { return _plateauSize; }

    public void PlateauSpacing(float spacing) { _plateauSpacing = spacing; }
    public float PlateauSpacing() { return _plateauSpacing; }


    #endregion
}
