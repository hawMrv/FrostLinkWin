/* FieldGenerator
 * 
 * This script creates the playfield by instantiating an 2D array of gameobjects
 * Idea is to create them in a "randomized order", to variate shape, size, rotation etc.
 * 
 * parameters for field should be generated by textfile
 * 
 * @mrv 24
 * 
 * TO DO
 * 
 * Create Holes
 * Make sure PATH is available
 * Create Player Stuff ---->>> DONE
 * 
 */

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class FieldGenerator : MonoBehaviour
{
    #region PUBLICS

    public PlayerManager _PlayerManager;

    [Space(10)]

    public GameObject[] _PlayFieldPlane = new GameObject[2];

    [Space(10)]

    public GameObject _PlateauObject;

    #endregion

    #region PRIVATES

    [Space(10)]

    [SerializeField]
    private int _fieldWidthNumber = 5;
    [SerializeField]
    private int _fieldHeightNumber = 10;
    [SerializeField]
    private int _plateauRotation = 0;
    [SerializeField]
    private float _plateauSize = 0.8f;
    [SerializeField]
    private int _holeChance = 10;

    [Space(10)]

    [SerializeField]
    private float _plateauSpacing = .3f;

    [SerializeField]
    private float _maxWidth = 1f;
    [SerializeField]
    private float _maxHeight = 1f;

    private GameObject[][] _PlateauA = new GameObject[0][];
    private GameObject[][] _PlateauB = new GameObject[0][];

    private bool[][] _holesA = new bool[0][];
    private bool[][] _holesB = new bool[0][];

    [SerializeField]
    private bool _showHoles = false;

    private bool _mirrorPlateauA = true;

    private PlateauProperties[][] _PlateauPropertiesA = new PlateauProperties[0][]; 
    private PlateauProperties[][] _PlateauPropertiesB = new PlateauProperties[0][];

    private Vector3 _tempVec = Vector3.zero;

    [Space(10)]

    // DEBUG STUFF
    [SerializeField]
    private bool _DEBUG_GENERATE = false;
    [SerializeField]
    private bool _DEBUG_DESTROY = false;

    #endregion

    #region UNITY_METHODS

    private void Start()
    {
        //GenerateField();
    }

    private void Update()
    {
        if (_DEBUG_GENERATE)
        {
            GenerateField();
            _DEBUG_GENERATE = false;
        }

        if (_DEBUG_DESTROY)
        {
            RemoveAllPlateaus();
            _DEBUG_DESTROY = false;
        }
    }

    #endregion

    #region METHODS

    public void GenerateField()
    {
        // in case field was generated before
        RemoveAllPlateaus();

        // creating all arrays
        _PlateauA = new GameObject[_fieldWidthNumber][];
        _PlateauB = new GameObject[_fieldWidthNumber][];

        _PlateauPropertiesA = new PlateauProperties[_fieldWidthNumber][];  
        _PlateauPropertiesB = new PlateauProperties[_fieldWidthNumber][]; 

        _holesA = new bool[_fieldWidthNumber][];
        _holesB = new bool[_fieldWidthNumber][];

        for (int i = 0; i < _fieldWidthNumber; i++)
        {
            _PlateauA[i] = new GameObject[_fieldHeightNumber];
            _PlateauB[i] = new GameObject[_fieldHeightNumber];
            _holesA[i] = new bool[_fieldHeightNumber];
            _holesB[i] = new bool[_fieldHeightNumber];
            _PlateauPropertiesA[i] = new PlateauProperties[_fieldHeightNumber];
            _PlateauPropertiesB[i] = new PlateauProperties[_fieldHeightNumber];
        }

        Debug.LogWarning("Plateau Holes are generated randomly", this);

        int randomInt = 0;              // defines which plateau object is used for generation
        float randomRotation = 0f;      // rotates all plateaus randomly
        float randomScaleOffset = 0f;   // varies the size of plateaus minimaly
        float plateauUnitSize = _plateauSize + (_plateauSpacing * .5f); // plateauUnitSize is the "Size-per-field", including diameter of plateau and spacing!

        // filling PlayFields
        for (int i = 0; i < _PlateauA.Length; i++)
        {
            for (int j = 0; j < _PlateauA[i].Length; j++)
            {
                // randomly assigning Plateau-Object
                randomInt = Mathf.RoundToInt(UnityEngine.Random.Range(0f, 2f));
                _PlateauA[i][j] = Instantiate(_PlateauObject);
                _PlateauB[i][j] = Instantiate(_PlateauObject);
                _PlateauPropertiesA[i][j] = _PlateauA[i][j].GetComponent<PlateauProperties>();
                _PlateauPropertiesB[i][j] = _PlateauB[i][j].GetComponent<PlateauProperties>();

                _PlateauPropertiesA[i][j].EnablePlateauModel(randomInt);
                _PlateauPropertiesB[i][j].EnablePlateauModel(randomInt);

                // assigning IDs to Plateaus
                _PlateauPropertiesA[i][j].ID(i, j);
                _PlateauPropertiesB[i][j].ID(i, j);

                // assigning PlayfieldType
                _PlateauPropertiesA[i][j].PlayerType(0);
                _PlateauPropertiesB[i][j].PlayerType(1);

                // assigning Names to Plateaus
                _PlateauA[i][j].name = "Plateau_" + i + "_" + j;
                _PlateauB[i][j].name = "Plateau_" + i + "_" + j;

                // assigning Plateaus to parent playfield
                _PlateauA[i][j].transform.SetParent(_PlayFieldPlane[0].transform);
                _PlateauB[i][j].transform.SetParent(_PlayFieldPlane[1].transform);

                // defining Dimensions
                _maxHeight = _fieldHeightNumber * plateauUnitSize;
                _maxWidth = _fieldWidthNumber * plateauUnitSize;

                // placing grid
                _tempVec = Vector3.zero;
                _tempVec.x = (i * plateauUnitSize) - (_maxWidth / 2f) + (plateauUnitSize / 2f);
                _tempVec.z = (j * plateauUnitSize) - (_maxHeight / 2f) + (plateauUnitSize / 2f);

                _PlateauA[i][j].transform.localPosition = _tempVec;// + _PlayFieldPlane[0].transform.position;
                _PlateauB[i][j].transform.localPosition = _tempVec;// + _PlayFieldPlane[1].transform.position;
                
                // randomly assigning Plateau-Orientation
                randomRotation = UnityEngine.Random.Range(0f, 360f);
                _tempVec = Vector3.zero;
                _tempVec.y = randomRotation;
                _PlateauA[i][j].transform.eulerAngles = _tempVec;
                _PlateauB[i][j].transform.eulerAngles = _tempVec;

                // set Plateau-Size
                randomScaleOffset = UnityEngine.Random.Range(0f, 0.2f);
                _tempVec = new Vector3(_plateauSize - randomScaleOffset, _plateauSize - randomScaleOffset, _plateauSize - randomScaleOffset);
                _PlateauA[i][j].transform.localScale = _tempVec;
                _PlateauB[i][j].transform.localScale = _tempVec;

                // assigning holes (NEEDS REFACTORING!!!)
                randomInt = Mathf.RoundToInt(UnityEngine.Random.Range(0f, 100f));
                //Debug.Log("randomInt is " + randomInt, this);

                if (randomInt <= _holeChance)
                {
                    //Debug.Log("Setting holes to TRUE", this);
                    _holesA[i][j] = true;
                    _holesB[i][j] = true;
                }
                else
                {
                    _holesA[i][j] = false;
                    _holesB[i][j] = false;
                }

                _PlateauPropertiesA[i][j].IsHole(_holesA[i][j]);
                _PlateauPropertiesB[i][j].IsHole(_holesB[i][j]);

                _PlateauA[i][j].transform.position -= (_PlateauA[i][j].transform.up * i * j * 0.1f) + (_PlateauA[i][j].transform.up * 0.3f);
                _PlateauB[i][j].transform.position -= (_PlateauA[i][j].transform.up * i * j * 0.1f) + (_PlateauA[i][j].transform.up * 0.3f);

                _PlateauPropertiesA[i][j].Surface();
                _PlateauPropertiesB[i][j].Surface();

                _PlateauPropertiesA[i][j].ShowHoleVisibility(_showHoles);
                _PlateauPropertiesB[i][j].ShowHoleVisibility(_showHoles);
            }
        }
    }

    public void RemoveAllPlateaus()
    {
        try
        {
            for (int i = 0; i < _PlateauA.Length; i++)
            {
                for (int j = 0; j < _PlateauA[i].Length; j++)
                {
                    if (_PlateauA[i][j] != null) GameObject.Destroy(_PlateauA[i][j]);
                    if (_PlateauB[i][j] != null) GameObject.Destroy(_PlateauB[i][j]);

                    //Debug.Log("Destroying PLateau " + i + " " + j, this);
                }
            }
        }
        catch (Exception e)
        {
            Debug.LogError(e.Message);
        }
    }

    private void GenerateHoles()
    {

    }

    public void ShowHoles(bool show)
    {
        _showHoles = show;

        for (int i = 0; i < _PlateauPropertiesA.Length; i++)
        {
            for (int j = 0; j < _PlateauPropertiesA[i].Length; j++)
            {
                _PlateauPropertiesA[i][j].ShowHoleVisibility(_showHoles);
                _PlateauPropertiesB[i][j].ShowHoleVisibility(_showHoles);
            }
        }
    }

    public void SubmergeAllPlateaus()
    {
        for (int i = 0; i < _PlateauA.Length; i++)
        {
            for (int j = 0; j < _PlateauA[i].Length; j++)
            {
                if (_PlateauA[i][j] != null && _PlateauA[i][j].activeInHierarchy) _PlateauPropertiesA[i][j].Submerge();
                if (_PlateauB[i][j] != null && _PlateauA[i][j].activeInHierarchy) _PlateauPropertiesB[i][j].Submerge();
            }
        }
    }

    public void SubmergePlateausA()
    {
        for (int i = 0; i < _PlateauA.Length; i++)
        {
            for (int j = 0; j < _PlateauA[i].Length; j++)
            {
                if (_PlateauA[i][j] != null) _PlateauPropertiesA[i][j].Submerge();
            }
        }
    }

    public void MirrorPlayerStep(int type, int i, int j)
    {
        if (type == 0 && _mirrorPlateauA)
        {
            if (_PlateauB[i][j] != null && _PlateauA[i][j].activeInHierarchy) _PlateauPropertiesB[i][j].PlayerSteppedOnPlateau();
        }
        else if (type == 1)
        {
            if (_PlateauA[i][j] != null && _PlateauA[i][j].activeInHierarchy) _PlateauPropertiesA[i][j].PlayerSteppedOnPlateau();

            if (j == _fieldHeightNumber - 1) _PlayerManager.GameWon();
        }

        if (_PlateauA[i][j] != null && _PlateauA[i][j].activeInHierarchy) _PlateauPropertiesA[i][j].TriggerHole();
        if (_PlateauB[i][j] != null && _PlateauA[i][j].activeInHierarchy) _PlateauPropertiesB[i][j].TriggerHole();

        if (_holesA[i][j]) _PlayerManager.PlayerSteppedOnHole(type);
    }

    public void MirrorPlateauA(bool mirror)
    {
        _mirrorPlateauA = mirror;
    }

    #endregion
}
